declare type Key = string | number;
/**
 * FetchTracker help when you fetch some data asynchronically and in this time
 * you receive anther request for the same data. and you prefer to send the same
 * data for both requests instead of re-fetch
 *
 * @example
 * const tracker = FetchTracker();
 *
 * // before you go to fetch the data. check if the data currently fetched
 *
 * if (tracker.is_already_fetched("data_key")) {
 *      // the function return promise that will invoked by calling
 *      // tracker.start(key) and tracker.ended(key, value) or in case of failing tracker.failed(key, err)
 *      // see latter ...
 *      return tracker.wait_for("data_key")
 * }
 *
 *
 * // before you go to fetch the data
 * tracker.start("data_key");
 *
 * // if the fetcher success
 * tracker.ended("data_key", fetched_value);
 *
 * // if the fetcher failed
 * tracker.failed("data_key", some_err);
 *
 *
 *
 * @export
 * @class FetchTracker
 * @template T
 * @template unknown
 */
export declare class FetchTracker<T = unknown> {
    private __waiting;
    __on_ended_func: Set<(key: string | number, value: T) => void>;
    __wait_map?: (value: any) => any | T;
    __timeout?: number;
    constructor({ timeout, wait_map }?: {
        wait_map?: (value: any) => any | T;
        timeout?: number;
    });
    private __emit_ended_func;
    onEnded(func: (key: Key, value: T) => void): void;
    unlistenOnEnded(func: (key: Key, value: T) => void): void;
    is_already_fetched(key: Key): boolean;
    await_for(key: Key): Promise<T | any>;
    start(key: Key): void;
    ended(key: Key, value: T): void;
    failed(key: Key, err: any): void;
}
export {};
