interface asyncQueueOptions {
    onlyLast?: boolean;
    maxParallelCalling?: number;
    static?: boolean;
}
interface FunctionStatus {
    isRunning: boolean;
    queueCount: number;
    runningCount: number;
}
export declare function getQueuedCallingStatus(key: any, functionName?: string): FunctionStatus | {
    [key: string]: FunctionStatus;
};
/**
 *
 * Call async functions in a queue. it is good when you don't want some async function run more the X times in the same time.
 *
 * @Options
 * @prop onlyLast (boolean, default: false) - in case of multiple accumulated functions in a queue, exec only the last called function (all middle functions in the queue will get the result of the last one)
 * @prop maxParallelCalling (number, default: 1) - enable multiple functions to run in parallel
 * @prop static (boolean, default: false) - when true:
 * in case of class all the method in all instances will insert to the same queue.
 * in case of function all wrapped of the same function will insert to the same queue.
 *
 *
 * @usage
 * option 1 wrap a function:
 * queuedCalling([Options])(<Your function>)
 * option 2 use it as a decorator on some method
 * class SomeClass {
 *  @queuedCalling([Options])
 *  async someMethod() {
 *  }
 * }
 *
 */
export declare const queuedCalling: ({ maxParallelCalling: max, onlyLast, static: _static }?: asyncQueueOptions) => <T extends Function = any>(targetOrFunc: any, propertyKey?: string, descriptor?: PropertyDescriptor) => void | T;
export {};
