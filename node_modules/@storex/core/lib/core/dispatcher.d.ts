export interface dependenceDispatcher {
    dispatcher: Dispatcher;
    links: {
        onEvents?: string[];
        invokes?: string[];
    }[];
}
export interface DispatcherArgs {
    events?: string[];
    dependencies?: (Dispatcher | dependenceDispatcher)[];
}
export interface DispatcherRegisterOptions {
    dispatcher: Dispatcher;
    on?: string[];
}
export declare class Dispatcher<T = any> {
    _is_async: boolean;
    _events: any;
    _waited_to_update_events: Set<unknown>;
    _waited_to_update_funcs: Set<Function>;
    _dispatch_count: number;
    _eventsRegisterFunc: {
        [key: string]: Set<(a: any) => any>;
    };
    context: T;
    constructor({ events, dependencies }?: DispatcherArgs);
    static register(func: any, dispatchers: (Dispatcher | DispatcherRegisterOptions)[]): void;
    dispatchOnce: (func: any) => Promise<void>;
    static unregister(func: any, dispatchers: (Dispatcher | DispatcherRegisterOptions)[]): void;
    _sentOnChange: () => this;
    register: (func: (a: this) => any, eventNames?: string[]) => void;
    unregisterFromAll: (func: any) => void;
    unregister: (func: any, eventNames?: string[]) => void;
    dispatch(eventNames?: string[]): void;
}
